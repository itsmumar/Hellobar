metric_fu shift the first line
================================================================================
 ./app/controllers/admin/access_controller.rb
================================================================================
   class Admin::AccessController < ApplicationController
     layout "admin"
-- 
     before_filter :require_admin, :only => [:reset_password, :do_reset_password, :logout_admin]
     before_filter :redirect_admin, :only => :step1
-- 
     def do_reset_password
       if current_admin.password_hashed != current_admin.encrypt_password(params[:existing_password])
         @error = "Your existing password is incorrect"
--     elsif params[:new_password] != params[:new_password_again]
!!       @error = "Your new passwords did not match each other"
--     elsif !params[:new_password] or params[:new_password].length < Admin::MIN_PASSWORD_LENGTH
!!       @error = "New password must be at least #{Admin::MIN_PASSWORD_LENGTH} chars"
--     elsif params[:new_password] == params[:existing_password]
!!       @error = "New password must be different than existing password."
--     end
-- 
       if @error
         flash.now[:error] = @error
         render :reset_password
--     else
         current_admin.reset_password!(params[:new_password])
         redirect_to admin_path
--     end
--   end
-- 
     def logout_admin
       current_admin.logout!
       session.delete(:admin_token)
       flash[:success] = "You are now logged out."
-- 
       redirect_to admin_access_path
--   end
-- 
     def process_step1
       return redirect_to(admin_access_path) unless email = params[:login_email]
-- 
       session[:admin_access_email] = email
-- 
       unless Admin.any_validated_access_token?(access_token) || verify_recaptcha
!!       return redirect_to(admin_access_path)
--     end
-- 
       Admin.record_login_attempt(email, remote_ip, user_agent, access_cookie)
-- 
       if @admin = Admin.where(:email => email).first
         process_login(@admin)
--     else
--       # Always render step2 - this way attackers don't know if the login
--       # email is valid or not
!!       render(:step2)
--     end
--   end
-- 
     def process_step2
       return redirect_to(admin_access_path) unless email = session[:admin_access_email]
-- 
       @admin = Admin.where(:email => email).first
-- 
       return render(:step2) unless @admin
       return redirect_to(admin_locked_path) if @admin.locked?
       return render(:validate_access_token) unless @admin.has_validated_access_token?(access_token)
-- 
       if @admin.validate_login(access_token, params[:admin_password], params[:mobile_code])
--       # Successful login
         session[:admin_token] = @admin.session_token
         redirect_to admin_path
--     else
         flash.now[:error] = "Invalid mobile code or password or too many attempts"
         render :step2
--     end
--   end
-- 
     def lockdown
!!     if Admin.validate_lockdown(params[:email], params[:key], params[:timestamp].to_i)
!!       Admin.lockdown!
!!       render :text => "Admins have been successfully locked down"
--     else
!!       render :text => "Admins could not be locked down"
--     end
--   end
-- 
     def validate_access_token
       return redirect_to(admin_access_path) unless email = params[:email]
-- 
       admin = Admin.where(:email => email).first
-- 
       return render(:step2) unless admin
       return redirect_to(admin_locked_path) if admin.locked?
-- 
       if admin.validate_access_token(access_token, params[:key], params[:timestamp].to_i)
         process_login(admin)
--     else
!!       render :validate_access_token
--     end
--   end
-- 
     private
-- 
     def process_login(admin)
       return redirect_to(admin_locked_path) if admin.locked?
-- 
--     # If they have validated the access token then we
--     # can render step 2
       if admin.has_validated_access_token?(access_token)
         if admin.needs_mobile_code?(access_token)
           admin.send_new_mobile_code!
--       end
--     else
         admin.send_validate_access_token_email!(access_token)
         return render(:validate_access_token)
--     end
-- 
--     # Might get locked in the process of sending a new mobile code
--     # (exceeds attempts)
       return redirect_to(admin_locked_path) if admin.locked?
-- 
       render(:step2)
--   end
-- 
     def redirect_admin
!!     return redirect_to(admin_path) if current_admin
--   end
-- end

================================================================================
 ./app/controllers/admin/users_controller.rb
================================================================================
   class Admin::UsersController < ApplicationController
     layout "admin"
-- 
     before_filter :require_admin
-- 
     def index
!!     if params[:q].blank?
!!       users = User.all
--     else
!!       users = User.where("email like ?", "%#{params[:q]}%").all
--     end
-- 
!!     @users = users.page(params[:page])
--   end
-- 
     def impersonate
       @user = User.find(params[:id])
       session[:impersonated_user] = @user.id
-- 
       redirect_to after_sign_in_path_for(@user)
--   end
-- 
     def unimpersonate
       session.delete(:impersonated_user)
       redirect_to admin_users_path
--   end
-- end

================================================================================
 ./app/controllers/admin_controller.rb
================================================================================
   class AdminController < ApplicationController
     layout "admin"
     before_filter :require_admin
-- 
     def index
!!     @optimizely_experiments = InternalReport.where("name like 'Optimizely: %'").select("DISTINCT(NAME)").map{|p| p["NAME"]}
--   end
-- end

================================================================================
 ./app/controllers/application_controller.rb
================================================================================
   class ApplicationController < ActionController::Base
     protect_from_forgery with: :exception
-- 
     helper_method :access_token, :current_admin, :impersonated_user, :current_site
-- 
     before_filter :record_tracking_param
-- 
     def access_token
       @access_token ||= Digest::SHA256.hexdigest(["hellobar", remote_ip, user_agent, access_cookie, "a776b"].join)
--   end
-- 
     def access_cookie
       cookies[:adxs] ||= {
         :value => Digest::SHA256.hexdigest(["a", rand(10_000), Time.now.to_f, user_agent, "d753d"].collect{|s| s.to_s}.join),
--       :expires => 90.days.from_now,
--       :httponly => true
--     }
--   end
-- 
     def user_agent
       request.user_agent
--   end
-- 
     def remote_ip
       request.remote_ip
--   end
-- 
     def current_admin
       @current_admin ||= Admin.validate_session(access_token, session[:admin_token])
--   end
-- 
     def require_admin
       if current_admin.nil?
         redirect_to root_path
       elsif current_admin.needs_to_set_new_password?
!!       redirect_to(admin_reset_password_path) unless URI.parse(url_for).path == admin_reset_password_path
--     end
--   end
-- 
     def after_sign_in_path_for(resource)
       if current_user.sites.any?
         site_path(current_user.sites.last)
--     else
!!       new_site_path
--     end
--   end
-- 
     def current_user
       impersonated_user || super
--   end
-- 
     def authenticate_user!
       impersonated_user ? true : super
--   end
-- 
     def impersonated_user
       current_admin && session[:impersonated_user] ? User.find_by_id(session[:impersonated_user]) : nil
--   end
-- 
     def current_site
       if current_user && session[:current_site]
         current_user.sites.where(:id => session[:current_site]).first || current_user.sites.first
       elsif current_user
         current_user.sites.first
--     else
--       nil
--     end
--   end
-- 
     def record_tracking_param
       Hello::TrackingParam.track(params[:trk]) if params[:trk]
--   end
-- end

================================================================================
 ./app/controllers/contact_submissions_controller.rb
================================================================================
   class ContactSubmissionsController < ApplicationController
     before_filter :authenticate_user!
     include SitesHelper
-- 
     def email_developer
       @site = current_user.sites.find(params[:site_id])
-- 
       if params[:developer_email].blank?
!!       flash[:error] = "Please enter your developer's email address."
--     else
         email_params = {
--         :site_url => display_url_for_site(@site),
--         :script_url => @site.script_url,
--         :user_email => current_user.email
--       }
-- 
         MailerGateway.send_email("Contact Developer 2", params[:developer_email], email_params)
         flash[:success] = "We've sent the installation instructions to your developer!"
--     end
-- 
       redirect_to site_path(@site)
--   end
-- 
     def generic_message
       @site = current_user.sites.find_by_id(params[:site_id])
-- 
       email_params = {
--       :first_name => current_user.first_name,
--       :last_name => current_user.last_name,
--       :email => current_user.email,
--       :message => params[:message],
         :preview => (params[:message] || "")[0, 50]
--     }
-- 
       email_params.merge!(:website => @site.url) if @site
-- 
       MailerGateway.send_email("Contact Form", "support@hellobar.com", email_params)
       flash[:success] = "Your message has been sent!"
-- 
       redirect_to params[:return_to]
--   end
-- end

================================================================================
 ./app/controllers/site_elements_controller.rb
================================================================================
   class SiteElementsController < ApplicationController
     before_filter :authenticate_user!
     before_filter :load_site
     before_filter :load_site_element, :only => [:edit, :update, :destroy, :pause, :unpause]
-- 
     layout "with_sidebar"
-- 
     def new
!!     @site_element = Bar.new
--   end
-- 
     def create
!!     @site_element = Bar.new(site_element_params)
-- 
!!     if @site_element.valid?
!!       @site_element.save!
!!       @site.generate_script
!!       flash[:success] = "Your bar was successfully created."
!!       redirect_to site_site_elements_path(:site_id => @site)
--     else
!!       flash.now[:error] = "There was a problem creating your bar."
!!       render :action => :new
--     end
--   end
-- 
     def update
!!     if @site_element.update_attributes(site_element_params)
!!       @site.generate_script
!!       flash[:success] = "Your bar was successfully updated."
!!       redirect_to site_site_elements_path(:site_id => @site)
--     else
!!       flash.now[:error] = "There was a problem updating your bar."
!!       render :action => :edit
--     end
--   end
-- 
     def destroy
!!     @site_element.destroy
!!     @site.generate_script
!!     flash[:success] = "Your bar was successfully deleted."
!!     redirect_to site_site_elements_path(:site_id => @site)
--   end
-- 
     def pause
!!     @site_element.update_attribute(:paused, true)
!!     @site.generate_script
!!     redirect_to site_site_elements_path(:site_id => @site)
--   end
-- 
     def unpause
!!     @site_element.update_attribute(:paused, false)
!!     @site.generate_script
!!     redirect_to site_site_elements_path(:site_id => @site)
--   end
-- 
     private
-- 
     def load_site
!!     @site = current_user.sites.find(params[:site_id])
--   end
-- 
     def load_site_element
!!     @site_element = Bar.find(params[:id])
!!     raise ActiveRecord::RecordNotFound unless @site_element.rule.try(:site) == @site
--   end
-- 
     def site_element_params
!!     params.require(:site_element).permit(:rule_id, :bar_type)
--   end
-- end

================================================================================
 ./app/controllers/sites_controller.rb
================================================================================
   class SitesController < ApplicationController
     include SitesHelper
-- 
     before_filter :authenticate_user!
     before_filter :load_site, :only => [:show, :edit, :update, :email_developer, :destroy]
-- 
     layout "with_sidebar"
-- 
     def create
       @site = Site.new(site_params)
-- 
       if @site.save
         SiteMembership.create!(:site => @site, :user => current_user)
-- 
         @site.create_default_rule
         @site.generate_script
-- 
         flash[:success] = "Your site was successfully created."
         redirect_to site_path(@site)
--     else
!!       flash.now[:error] = "There was a problem creating your site."
!!       render :action => :new
--     end
--   end
-- 
     def new
!!     @site = Site.new
--   end
-- 
     def show
       session[:current_site] = @site.id
--   end
-- 
     def update
!!     if @site.update_attributes(site_params)
!!       flash[:success] = "Your settings have been updated."
!!       redirect_to site_path(@site)
--     else
!!       flash.now[:error] = "There was a problem updating your settings."
!!       render :action => :edit
--     end
--   end
-- 
     def destroy
!!     @site.destroy
!!     flash[:success] = "Your site has been successfully deleted"
-- 
!!     redirect_to(current_site ? site_path(current_site) : new_site_path)
--   end
-- 
     private
-- 
     def site_params
       params.require(:site).permit(:url, :opted_in_to_email_digest)
--   end
-- 
     def load_site
       @site = current_user.sites.find(params[:id])
--   end
-- end

================================================================================
 ./app/controllers/user_controller.rb
================================================================================
   class UserController < ApplicationController
     layout "with_sidebar"
-- 
     before_filter :authenticate_user!
     before_filter :load_user, :only => [:edit, :update]
-- 
     def update
       if @user.update_attributes(user_params)
         sign_in @user, :bypass => true
         flash[:success] = "Your settings have been updated."
         redirect_to current_site ? site_path(current_site) : new_site_path
--     else
!!       flash.now[:error] = "There was a problem updating your settings."
!!       render :action => :edit
--     end
--   end
-- 
-- 
     private
-- 
     def load_user
       @user = current_user
--   end
-- 
     def user_params
       if params[:user] && params[:user][:password].blank?
         params[:user].delete(:password)
         params[:user].delete(:password_confirmation)
--     end
-- 
       params.require(:user).permit(:email, :first_name, :last_name, :password, :password_confirmation)
--   end
-- end

================================================================================
 ./app/controllers/users/passwords_controller.rb
================================================================================
   class Users::PasswordsController < Devise::PasswordsController
     def create
       if Hello::WordpressUser.email_exists?(params[:user].try(:[], :email))
         render "pages/redirect_forgot"
--     else
         super
--     end
--   end
-- end

================================================================================
 ./app/controllers/users/sessions_controller.rb
================================================================================
   class Users::SessionsController < Devise::SessionsController
     def create
       if Hello::WordpressUser.email_exists?(params[:user].try(:[], :email))
         render "pages/redirect_login"
--     else
         super
--     end
--   end
-- end

================================================================================
 ./app/controllers/welcome_controller.rb
================================================================================
   class WelcomeController < ApplicationController
-- end

================================================================================
 ./app/controllers/wordpress_plugin_controller.rb
================================================================================
   class WordpressPluginController < ApplicationController
     before_filter :authenticate_user!
     before_filter :load_site
-- 
     layout false
-- 
     def show
       plugin = WordpressPlugin.new(@site)
       send_data(plugin.to_zip, :type => Mime::ZIP, :filename => "hellobar_wp_plugin.zip")
--   ensure
       plugin.cleanup
--   end
-- 
-- 
     private
-- 
     def load_site
       @site = current_user.sites.find(params[:site_id])
--   end
-- end

================================================================================
 ./app/models/admin_login_attempt.rb
================================================================================
   class AdminLoginAttempt < ActiveRecord::Base
-- end

================================================================================
 ./app/models/bar.rb
================================================================================
   class Bar < ActiveRecord::Base
     BAR_TYPES = %w{
--     traffic
--     email
--     social/tweet_on_twitter
--     social/follow_on_twitter
--     social/like_on_facebook
--     social/share_on_linkedin
--     social/plus_one_on_google_plus
--     social/pin_on_pinterest
--     social/follow_on_pinterest
--     social/share_on_buffer
--   }
-- 
     belongs_to :rule
-- 
     validates :bar_type, presence: true, inclusion: { in: BAR_TYPES }
-- 
     scope :paused, -> { where(paused: true) }
     scope :active, -> { where(paused: false) }
-- 
     delegate :site, to: :rule, allow_nil: true
-- 
     serialize :settings, Hash
-- 
     def total_views
!!     return 0 unless site
-- 
!!     this_data = site.get_all_time_data.detect{|b| b.bar_id.to_i == self.id.to_i}
!!     this_data.try(:views) || 0
--   end
-- 
     def total_conversions
!!     return 0 unless site
-- 
!!     this_data = site.get_all_time_data.detect{|b| b.bar_id.to_i == self.id.to_i}
!!     this_data.try(:conversions) || 0
--   end
-- end

================================================================================
 ./app/models/condition.rb
================================================================================
   class Condition < ActiveRecord::Base
     self.inheritance_column = 'segment'
-- 
     OPERANDS = {
--     is_after: 'is after',
--     is_before: 'is before',
--     is_between: 'is between',
--     is: 'is',
--     is_not: 'is not',
--     includes: 'includes',
--     excludes: 'excludes'
--   }
-- 
     belongs_to :rule
-- end

================================================================================
 ./app/models/condition/date_condition.rb
================================================================================
   class DateCondition < Condition
--   # { start_date: <DateTime>, end_date: <DateTime> }
     serialize :value, Hash
-- 
     def self.create_from_params(start_date, end_date)
       return unless [start_date, end_date].any?(&:present?)
-- 
       if [start_date, end_date].all?(&:present?)
         operand = Condition::OPERANDS[:is_between]
         value = { 'start_date' => start_date, 'end_date' => end_date }
--     elsif start_date.present?
         operand = Condition::OPERANDS[:is_after]
         value = { 'start_date' => start_date }
--     elsif end_date.present?
         operand = Condition::OPERANDS[:is_before]
         value = { 'end_date' => end_date }
--     end
-- 
       create operand: operand,
--            value: value
--   end
-- end

================================================================================
 ./app/models/condition/url_condition.rb
================================================================================
   class UrlCondition < Condition
--   # { include_url: <DateTime>, exclude_url: <DateTime> }
     serialize :value, Hash
-- 
     def self.create_include_url(url)
       UrlCondition.create operand: Condition::OPERANDS[:includes],
--                         value: { 'include_url' => url }
--   end
-- 
     def self.create_exclude_url(url)
       UrlCondition.create operand: Condition::OPERANDS[:excludes],
--                         value: { 'exclude_url' => url }
--   end
-- 
     def url
       value['include_url'] || value['exclude_url']
--   end
-- end

================================================================================
 ./app/models/internal_event.rb
================================================================================
   class InternalEvent < ActiveRecord::Base
-- end

================================================================================
 ./app/models/internal_prop.rb
================================================================================
   class InternalProp < ActiveRecord::Base
-- end
-- 
   module HasInternalProps
     def internal_props
!!     unless @internal_props
!!       @internal_props = {}
!!       InternalProp.where(:target_type=>self.class.name.underscore, :target_id=>self.id).order(:timestamp).each do |prop|
!!         @internal_props[prop.name] = prop.value
--       end
--     end
!!     @internal_props
--   end
-- end

================================================================================
 ./app/models/internal_report.rb
================================================================================
   class InternalReport < ActiveRecord::Base
     serialize :data, JSON
-- 
     class << self
       def clear
         destroy_all
--     end
-- 
       def set(name, data)
         report = InternalReport.where(name: name).first || InternalReport.new
         report.name = name
         report.data = data
         report.save!
--     end
-- 
       def get(name)
         InternalReport.where(name: name).first
--     end
-- 
       def get_data(name)
         report = InternalReport.get(name)
         return nil unless report
         begin
           report.try :data
!!       rescue NoMethodError
!!         nil
--       end
--     end
-- 
       def generate_all
         generate_top_referrer_metrics
         generate_over_time_metrics
         generate_optimizely_metrics
         generate_installed_email_digest_metrics
         generate_not_installed_email_digest_metrics
--     end
-- 
       def generate_top_referrer_metrics
         set("referrer", generate_kpis_via_dimension("referrer"))
--     end
-- 
       def generate_over_time_metrics
         now = Time.now
         set("over_time_by_day", generate_kpis_via_date_range(now-7.days, now, "%Y-%m-%d", 1.day))
         set("over_time_by_week", generate_kpis_via_date_range(now-1.year, now, "Week of %Y.%m.%d", 7.days))
--     end
-- 
       def generate_optimizely_metrics
         experiments = InternalProp.where("name like 'Optimizely: %'").select("DISTINCT(NAME)").map{|p| p["NAME"]}
-- 
         experiments.each do |experiment|
!!         set(experiment, generate_kpis_via_dimension(experiment))
--       end
--     end
-- 
       def generate_installed_email_digest_metrics
         variations = (1..8).map{|w| "installed_v1_w#{w}"}
         links = %w(create_bar_cta create_bar_button unsubscribe)
         generate_email_digest_metrics("installed_email_digest", variations, links)
--     end
-- 
       def generate_not_installed_email_digest_metrics
         variations = (1..4).map{|w| "not_installed_v1_w#{w}"}
         links = %w(install unsubscribe)
         generate_email_digest_metrics("not_installed_email_digest", variations, links)
--     end
-- 
       def generate_email_digest_metrics(name, variations, links)
         metrics = {}
-- 
         variations.map(&:to_sym).each do |variation|
           metrics[variation] = {
--           "total" => InternalProp.where(:name => variation).count,
--           "opens" => InternalEvent.where(:name => "Opened email: #{variation}").select(:target_id).uniq.count
--         }
-- 
           links.each do |link|
             metrics[variation]["Clicked link: #{link}"] = InternalEvent.where(:name => "Clicked link: #{variation}_#{link}").select(:target_id).uniq.count
--         end
--       end
-- 
         set(name, metrics)
--     end
-- 
       def generate_kpis_via_dimension(dimension, options={})
         cxn = ActiveRecord::Base.connection
         sql = %{SELECT
--         #{internal_people_select},
--         internal_dimensions.value
--       FROM internal_people, internal_dimensions
--       WHERE
--         internal_dimensions.name = #{cxn.quote(dimension)} AND
--         internal_people.id = internal_dimensions.person_id
--       }
         generate_kpis_from_sql(sql, options)
--     end
-- 
       def generate_kpis_via_date_range(start_date, end_date, date_format, date_unit, options={})
         sql = %{SELECT
--         #{internal_people_select},
--         DATE_FORMAT(FROM_UNIXTIME(FLOOR(IFNULL(internal_people.first_visited_at, internal_people.signed_up_at)/#{date_unit})*#{date_unit}), '#{date_format}')
-- 
--       FROM internal_people
--       WHERE
--         IFNULL(internal_people.first_visited_at, internal_people.signed_up_at) >= #{start_date.to_i} AND
--         IFNULL(internal_people.first_visited_at, internal_people.signed_up_at) <= #{end_date.to_i}
--       }
         generate_kpis_from_sql(sql, options)
--     end
-- 
       def internal_people_select
--       %{internal_people.signed_up_at,
--         internal_people.completed_registration_at,
--         internal_people.created_first_bar_at,
--         internal_people.created_second_bar_at,
           internal_people.received_data_at}
--     end
-- 
       def generate_kpis_from_sql(sql, options={})
         results = Hash.new{|h,k| h[k] = {total: 0, signed_up: 0, completed_registration: 0, created_first_bar: 0, created_second_bar: 0, installed: 0, total_time_first_bar: 0}}
         dimension_lookups = nil
         if options[:dimension_lookups]
!!         dimension_lookups = {}
!!         options[:dimension_lookups].each do |value, keys|
!!           keys.each do |key|
!!             dimension_lookups[key] = value
--           end
--         end
--       end
--       
         ActiveRecord::Base.connection.execute(sql).each do |row|
!!         signed_up_at, completed_registration_at, created_first_bar_at, created_second_bar_at, received_data_at, value = *row
!!         key = value
!!         if dimension_lookups
!!           key = dimension_lookups[key] || dimension_lookups[:*] || key
--         end
!!         result = results[key]
!!         result[:total] += 1
!!         result[:signed_up] += 1 if signed_up_at
!!         result[:completed_registration] += 1 if completed_registration_at
!!         result[:created_first_bar] += 1 if created_first_bar_at
!!         result[:created_second_bar] += 1 if created_second_bar_at
!!         result[:installed] += 1 if received_data_at
!!         result[:total_time_first_bar] += (created_first_bar_at-signed_up_at) if created_first_bar_at and signed_up_at and created_first_bar_at-signed_up_at < 30*60
--       end
         return results
--     end
--   end
-- end

================================================================================
 ./app/models/mailer_gateway.rb
================================================================================
   class MailerGateway
     def self.gateway
!!     GrandCentralApi.new("http://central.crazyegg.com", Hellobar::Settings[:grand_central_api_key], Hellobar::Settings[:grand_central_api_secret])
--   end
-- 
     def self.send_email(type, recipient = "support@hellobar.com", params = {})
!!     gateway.send_mail(type, {recipient => params})
--   end
-- end

================================================================================
 ./app/models/rule.rb
================================================================================
   class Rule < ActiveRecord::Base
     MATCH_ON = {
--     all: 'all',
--     any: 'any'
--   }
-- 
     belongs_to :site
-- 
     has_many :bars
     has_many :conditions
-- end

================================================================================
 ./app/models/site.rb
================================================================================
   class Site < ActiveRecord::Base
     include GuaranteedQueue::Delay
-- 
     has_many :rules
     has_many :bars, through: :rules
     has_many :site_memberships, dependent: :destroy
     has_many :users, through: :site_memberships
-- 
     before_validation :standardize_url
-- 
     before_destroy :blank_out_script
-- 
     validates_with UrlValidator, url_field: :url
-- 
     def owner
       if membership = site_memberships.where(:role => "owner").first
         membership.user
--     else
--       nil
--     end
--   end
-- 
     def has_script_installed?
       if script_installed_at.nil? && bars.any?{|b| b.total_views > 0}
         update_attribute(:script_installed_at, Time.current)
         InternalEvent.create(:timestamp => script_installed_at.to_i, :target_type => "user", :target_id => owner.try(:id), :name => "Received Data")
--     end
-- 
       script_installed_at.present?
--   end
-- 
     def script_url
       "s3.amazonaws.com/#{Hellobar::Settings[:s3_bucket]}/#{script_name}"
--   end
-- 
     def script_name
       raise "script_name requires ID" unless persisted?
       "#{Digest::SHA1.hexdigest("bar#{id}cat")}.js"
--   end
-- 
     def script_content(compress = true)
       ScriptGenerator.new(self, :compress => compress).generate_script
--   end
-- 
     def generate_script
       delay :generate_static_assets
--   end
-- 
     def blank_out_script
       delay :generate_blank_static_assets
--   end
-- 
     def get_all_time_data
!!     @all_time_data ||= Hello::BarData.get_all_time_data(id)
--   end
-- 
     def create_default_rule
       return unless rules.empty?
-- 
       rules.create!(:name => "Everyone",
--                   :match => Rule::MATCH_ON[:all])
--   end
-- 
     private
-- 
     def generate_static_assets(options = {})
       update_attribute(:script_attempted_to_generate_at, Time.now)
-- 
       Timeout::timeout(20) do
         generated_script_content = options[:script_content] || script_content(true)
         Hello::AssetStorage.new.create_or_update_file_with_contents(script_name, generated_script_content)
--     end
-- 
       update_attribute(:script_generated_at, Time.now)
--   end
-- 
     def generate_blank_static_assets
       generate_static_assets(:script_content => "")
--   end
-- 
     def standardize_url
       url = Addressable::URI.heuristic_parse(self.url)
-- 
       self.url = "#{url.scheme}://#{url.normalized_host}"
--   end
-- end

================================================================================
 ./app/models/site_membership.rb
================================================================================
   class SiteMembership < ActiveRecord::Base
     belongs_to :user
     belongs_to :site
-- 
     validates :user_id, :uniqueness => {:scope => :site_id}
     validate :only_one_owner_per_site
-- 
-- 
     private
-- 
     def only_one_owner_per_site
       if site && role == "owner" && !site.owner.nil? && site.owner != user
         self.errors.add(:role, "cannot be owner; one already exists for this site")
--     end
--   end
-- end

================================================================================
 ./app/models/validators/url_validator.rb
================================================================================
   class UrlValidator < ActiveModel::Validator
     def validate(record)
       field = options[:url_field]
       url = record.public_send(field)
-- 
       record.errors.add(field, "can't be blank") unless url.present?
-- 
       uri = Addressable::URI.parse(url)
-- 
       if !%w{http https}.include?(uri.scheme) || uri.host.blank? || !uri.ip_based? && url !~ /(^$)|(^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(([0-9]{1,5})?\/.*)?$)/ix
         record.errors.add(field, "is invalid")
--     end
--   rescue Addressable::URI::InvalidURIError
!!     record.errors.add(field, "is invalid")
--   end
-- end

================================================================================
 ./spec/controllers/admin/users_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe Admin::UsersController do
     fixtures :all
-- 
     before(:each) do
       @admin = admins(:joey)
--   end
-- 
     describe "POST impersonate" do
       it "allows the admin to impersonate a user" do
         stub_current_admin(@admin)
-- 
         post :impersonate, :id => users(:joey)
-- 
         controller.current_user.should == users(:joey)
--     end
--   end
-- 
     describe "DELETE unimpersonate" do
       it "allows the admin to stop impersonating a user" do
         stub_current_admin(@admin)
-- 
         post :impersonate, :id => users(:joey)
-- 
         controller.current_user.should == users(:joey)
-- 
         delete :unimpersonate
-- 
         controller.current_user.should be_nil
--     end
--   end
-- end

================================================================================
 ./spec/controllers/admin_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe AdminController do
-- 
-- end

================================================================================
 ./spec/controllers/application_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe ApplicationController do
     fixtures :all
-- 
     describe "current_site" do
       it "returns nil if no current_user" do
         stub_current_user(nil)
         controller.current_site.should be_nil
--     end
-- 
       it "returns current_user's first site if nothing is set in session" do
         user = stub_current_user(users(:joey))
         controller.current_site.should == user.sites.first
--     end
-- 
       it "returns site stored in session if available" do
         user = stub_current_user(users(:joey))
         site = user.sites.last
         session[:current_site] = site.id
-- 
         controller.current_site.should == site
--     end
-- 
       it "returns user's first site if site stored in session is not available or doesn't belong to user" do
         user = stub_current_user(users(:joey))
         session[:current_site] = sites(:polymathic).id
-- 
         controller.current_site.should == user.sites.first
--     end
-- 
       it "returns nil if user has no sites" do
         stub_current_user(users(:wootie))
         controller.current_site.should be_nil
--     end
--   end
-- 
     describe "record_tracking_param" do
       it "records the tracking param" do
         controller.stub(:params => {:trk => "asdf"})
-- 
         Hello::TrackingParam.should_receive(:track).with("asdf")
-- 
         controller.record_tracking_param
--     end
--   end
-- end

================================================================================
 ./spec/controllers/contact_submissions_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe ContactSubmissionsController do
     fixtures :all
-- 
     it "sends a 'email your developer' message" do
       dev_email = "dev@polymathic.me"
       site = sites(:zombo)
       user = stub_current_user(site.owner)
-- 
       email_params = {
--       :site_url => "zombo.com",
--       :script_url => site.script_url,
--       :user_email => user.email
--     }
-- 
       MailerGateway.should_receive(:send_email).with("Contact Developer 2", dev_email, email_params)
-- 
       post :email_developer, :developer_email => dev_email, :site_id => site.id
--   end
-- 
     it "sends a generic message" do
       site = sites(:zombo)
       user = stub_current_user(site.owner)
       message = "HELP ME"
       return_to = root_path
-- 
       email_params = {
--       :first_name => user.first_name,
--       :last_name => user.last_name,
--       :email => user.email,
--       :message => message,
--       :preview => message[0, 50],
--       :website => site.url
--     }
-- 
       MailerGateway.should_receive(:send_email).with("Contact Form", "support@hellobar.com", email_params)
-- 
       post :generic_message, :site_id => site.id, :message => message, :return_to => return_to
-- 
       response.should redirect_to(return_to)
--   end
-- 
     it "generic message works without a site" do
       user = stub_current_user(users(:joey))
       message = "HELP ME"
       return_to = root_path
-- 
       email_params = {
--       :first_name => user.first_name,
--       :last_name => user.last_name,
--       :email => user.email,
--       :message => message,
--       :preview => message[0, 50],
--     }
-- 
       MailerGateway.should_receive(:send_email).with("Contact Form", "support@hellobar.com", email_params)
-- 
       post :generic_message, :message => message, :return_to => return_to
-- 
       response.should redirect_to(return_to)
--   end
-- end

================================================================================
 ./spec/controllers/site_elements_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe SiteElementsController do
-- 
-- end

================================================================================
 ./spec/controllers/sites_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe SitesController do
     fixtures :all
-- 
     before(:each) do
       @user = users(:joey)
--   end
-- 
     describe "POST create" do
       it "allows a logged-in user to create a new site and sets him as the owner" do
         stub_current_user(@user)
-- 
         mock_storage = double("asset_storage")
         mock_storage.should_receive(:create_or_update_file_with_contents)
         Hello::AssetStorage.stub(:new => mock_storage)
-- 
         lambda {
           post :create, :site => {:url => "zombo.com"}
--       }.should change(@user.sites, :count).by(1)
-- 
         site = @user.sites.last
-- 
         site.url.should == "http://zombo.com"
         @user.role_for_site(site).should == :owner
--     end
-- 
       it 'creates a site with a rule set' do
         stub_current_user(@user)
-- 
         mock_storage = double("asset_storage")
         mock_storage.should_receive(:create_or_update_file_with_contents)
         Hello::AssetStorage.stub(:new => mock_storage)
-- 
         post :create, :site => {:url => "zombo.com"}
-- 
         site = @user.sites.last
-- 
         site.rules.size.should == 1
--     end
--   end
-- 
     describe "GET show" do
       it "sets current_site session value" do
         stub_current_user(@user)
         site = @user.sites.last
-- 
         get :show, :id => site
-- 
         session[:current_site].should == site.id
--     end
--   end
-- end

================================================================================
 ./spec/controllers/user_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe UserController do
     fixtures :all
-- 
     before(:each) do
       @user = users(:joey)
--   end
-- 
     describe "PUT update" do
       it "allows the user to change their password" do
         stub_current_user(@user)
         original_hash = @user.encrypted_password
-- 
         put :update, :user => {:password => "asdfffff", :password_confirmation => "asdfffff"}
-- 
         @user.reload.encrypted_password.should_not == original_hash
--     end
-- 
       it "allows the user to change other settings with blank password params" do
         stub_current_user(@user)
-- 
         put :update, :user => {:first_name => "Sexton", :last_name => "Hardcastle", :password => "", :password_confirmation => ""}
-- 
         @user.reload.first_name.should == "Sexton"
         @user.reload.last_name.should == "Hardcastle"
--     end
--   end
-- end

================================================================================
 ./spec/controllers/users/passwords_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe Users::PasswordsController do
     fixtures :all
-- 
     before(:each) do
       @request.env["devise.mapping"] = Devise.mappings[:user]
--   end
-- 
     describe "POST create" do
       it "sends a password reset with valid params" do
         user = users(:joey)
-- 
         MailerGateway.should_receive(:send_email).with("Reset Password", user.email, anything)
-- 
         post :create, :user => {:email => user.email}
--     end
-- 
       it "redirects if trying to reset with an email that's in the wordpress database" do
         Hello::WordpressUser.should_receive(:email_exists?).with("user@website.com").and_return(true)
-- 
         post :create, :user => {:email => "user@website.com"}
-- 
         response.should render_template("pages/redirect_forgot")
--     end
--   end
-- end

================================================================================
 ./spec/controllers/users/sessions_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe Users::SessionsController do
     fixtures :all
-- 
     before(:each) do
       @request.env["devise.mapping"] = Devise.mappings[:user]
--   end
-- 
     describe "POST create" do
       it "logs in a user with valid params" do
         controller.current_user.should be_nil
         post :create, :user => {:email => "joey@polymathic.me", :password => "password"}
         controller.current_user.should == users(:joey)
--     end
-- 
       it "should redirect if trying to sign in with an email that's in the wordpress database" do
         Hello::WordpressUser.should_receive(:email_exists?).with("user@website.com").and_return(true)
-- 
         post :create, :user => {:email => "user@website.com", :password => "asdfasdf"}
-- 
         response.should render_template("pages/redirect_login")
--     end
--   end
-- end

================================================================================
 ./spec/controllers/welcome_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe WelcomeController do
-- 
-- end

================================================================================
 ./spec/controllers/wordpress_plugin_controller_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe WordpressPluginController do
     fixtures :all
-- 
     it "generates the wordpress plugin without errors" do
       site = sites(:zombo)
       stub_current_user(site.owner)
-- 
       get :show, :site_id => site.to_param
-- 
       response.should be_success
       response.header["Content-Type"].should == "application/zip"
--   end
-- end

================================================================================
 ./spec/helpers/admin/users_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
-- # Specs in this file have access to a helper object that includes
-- # the Admin::UsersHelper. For example:
-- #
-- # describe Admin::UsersHelper do
-- #   describe "string concat" do
-- #     it "concats two strings with spaces" do
-- #       expect(helper.concat_strings("this","that")).to eq("this that")
-- #     end
-- #   end
-- # end
   describe Admin::UsersHelper do
-- end

================================================================================
 ./spec/helpers/contact_submissions_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
-- # Specs in this file have access to a helper object that includes
-- # the ContactSubmissionsHelper. For example:
-- #
-- # describe ContactSubmissionsHelper do
-- #   describe "string concat" do
-- #     it "concats two strings with spaces" do
-- #       expect(helper.concat_strings("this","that")).to eq("this that")
-- #     end
-- #   end
-- # end
   describe ContactSubmissionsHelper do
-- end

================================================================================
 ./spec/helpers/email_digest_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe EmailDigestHelper do
     describe "bar_activity_units" do
       before(:each) do
         @bars = {
--         :traffic =>                 Bar.new(:bar_type => "traffic"),
--         :email =>                   Bar.new(:bar_type => "email"),
--         :tweet_on_twitter =>        Bar.new(:bar_type => "social/tweet_on_twitter"),
--         :follow_on_twitter =>       Bar.new(:bar_type => "social/follow_on_twitter"),
--         :like_on_facebook =>        Bar.new(:bar_type => "social/like_on_facebook"),
--         :share_on_linkedin =>       Bar.new(:bar_type => "social/share_on_linkedin"),
--         :plus_one_on_google_plus => Bar.new(:bar_type => "social/plus_one_on_google_plus"),
--         :pin_on_pinterest =>        Bar.new(:bar_type => "social/pin_on_pinterest"),
--         :follow_on_pinterest =>     Bar.new(:bar_type => "social/follow_on_pinterest"),
--         :share_on_buffer =>         Bar.new(:bar_type => "social/share_on_buffer")
--       }
--     end
-- 
       it "returns the correct units for all bar types" do
         bar_activity_units(@bars[:traffic]).should == "click"
         bar_activity_units(@bars[:email]).should == "email"
         bar_activity_units(@bars[:tweet_on_twitter]).should == "tweet"
         bar_activity_units(@bars[:follow_on_twitter]).should == "follower"
         bar_activity_units(@bars[:like_on_facebook]).should == "like"
         bar_activity_units(@bars[:share_on_linkedin]).should == "share"
         bar_activity_units(@bars[:plus_one_on_google_plus]).should == "plus one"
         bar_activity_units(@bars[:pin_on_pinterest]).should == "pin"
         bar_activity_units(@bars[:follow_on_pinterest]).should == "follower"
         bar_activity_units(@bars[:share_on_buffer]).should == "share"
--     end
-- 
--     # not sure we'll end up needing this. also, verb is awkward for a lot of bar types.
-- #     it "optionally adds an appropriate verb" do
-- #       bar_activity_units(@bars[:traffic], :verb => true).should == "click recorded"
-- #       bar_activity_units(@bars[:email], :verb => true).should == "email collected"
-- #       bar_activity_units(@bars[:tweet_on_twitter], :verb => true).should == "tweet"
-- #       bar_activity_units(@bars[:follow_on_twitter], :verb => true).should == "follow gained"
-- #       bar_activity_units(@bars[:like_on_facebook], :verb => true).should == "like"
-- #       bar_activity_units(@bars[:share_on_linkedin], :verb => true).should == "share"
-- #       bar_activity_units(@bars[:plus_one_on_google_plus], :verb => true).should == "plus one"
-- #       bar_activity_units(@bars[:pin_on_pinterest], :verb => true).should == "pin"
-- #       bar_activity_units(@bars[:follow_on_pinterest], :verb => true).should == "follow gained"
-- #       bar_activity_units(@bars[:share_on_buffer], :verb => true).should == "share"
-- #     end
-- #     it "adjusts the verb to make sense for multiple bars with different units"
-- 
       it "optionally pluralizes the units" do
         bar_activity_units(@bars[:traffic], :plural => true).should == "clicks"
         bar_activity_units(@bars[:email], :plural => true).should == "emails"
         bar_activity_units(@bars[:tweet_on_twitter], :plural => true).should == "tweets"
         bar_activity_units(@bars[:follow_on_twitter], :plural => true).should == "followers"
         bar_activity_units(@bars[:like_on_facebook], :plural => true).should == "likes"
         bar_activity_units(@bars[:share_on_linkedin], :plural => true).should == "shares"
         bar_activity_units(@bars[:plus_one_on_google_plus], :plural => true).should == "plus ones"
         bar_activity_units(@bars[:pin_on_pinterest], :plural => true).should == "pins"
         bar_activity_units(@bars[:follow_on_pinterest], :plural => true).should == "followers"
         bar_activity_units(@bars[:share_on_buffer], :plural => true).should == "shares"
--     end
-- 
       it "consolidates multiple bar types into a unit that makes sense for all" do
         other_traffic_bar = Bar.new(:bar_type => "traffic")
         bar_activity_units([other_traffic_bar, @bars[:traffic]]).should == "click"
         bar_activity_units([other_traffic_bar, @bars[:traffic], @bars[:email]]).should == "action"
--     end
--   end
-- end

================================================================================
 ./spec/helpers/site_elements_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
-- # Specs in this file have access to a helper object that includes
-- # the SiteElementsHelper. For example:
-- #
-- # describe SiteElementsHelper do
-- #   describe "string concat" do
-- #     it "concats two strings with spaces" do
-- #       expect(helper.concat_strings("this","that")).to eq("this that")
-- #     end
-- #   end
-- # end
   describe SiteElementsHelper do
-- end

================================================================================
 ./spec/helpers/sites_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe SitesHelper do
     describe "display_url_for_site" do
       it "returns shorter URLs for different sites" do
         site = Site.new(:url => "http://asdf.com")
         helper.display_url_for_site(site).should == "asdf.com"
-- 
         site = Site.new(:url => "http://cs.horse.bike")
         helper.display_url_for_site(site).should == "cs.horse.bike"
--     end
--   end
-- end

================================================================================
 ./spec/helpers/user_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
-- # Specs in this file have access to a helper object that includes
-- # the UserHelper. For example:
-- #
-- # describe UserHelper do
-- #   describe "string concat" do
-- #     it "concats two strings with spaces" do
-- #       expect(helper.concat_strings("this","that")).to eq("this that")
-- #     end
-- #   end
-- # end
   describe UserHelper do
-- end

================================================================================
 ./spec/helpers/users/passwords_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
-- # Specs in this file have access to a helper object that includes
-- # the Users::PasswordsHelper. For example:
-- #
-- # describe Users::PasswordsHelper do
-- #   describe "string concat" do
-- #     it "concats two strings with spaces" do
-- #       expect(helper.concat_strings("this","that")).to eq("this that")
-- #     end
-- #   end
-- # end
   describe Users::PasswordsHelper do
-- end

================================================================================
 ./spec/helpers/users/sessions_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
-- # Specs in this file have access to a helper object that includes
-- # the Users::SessionsHelper. For example:
-- #
-- # describe Users::SessionsHelper do
-- #   describe "string concat" do
-- #     it "concats two strings with spaces" do
-- #       expect(helper.concat_strings("this","that")).to eq("this that")
-- #     end
-- #   end
-- # end
   describe Users::SessionsHelper do
-- end

================================================================================
 ./spec/helpers/wordpress_plugin_helper_spec.rb
================================================================================
   require 'spec_helper'
-- 
-- # Specs in this file have access to a helper object that includes
-- # the WordpressPluginHelper. For example:
-- #
-- # describe WordpressPluginHelper do
-- #   describe "string concat" do
-- #     it "concats two strings with spaces" do
-- #       expect(helper.concat_strings("this","that")).to eq("this that")
-- #     end
-- #   end
-- # end
   describe WordpressPluginHelper do
-- end

================================================================================
 ./spec/lib/hello/email_digest_spec.rb
================================================================================
   require "spec_helper"
-- 
   describe Hello::EmailDigest do
     fixtures :all
-- 
     describe "email_name" do
       it "returns the proper name for sites that have a script installed" do
         site = double("site", :created_at => 1.day.ago, :script_installed_at => 1.day.ago)
         Hello::EmailDigest.email_name(site).should == "installed_v1_w1"
-- 
         site = double("site", :created_at => 8.days.ago, :script_installed_at => 8.days.ago)
         Hello::EmailDigest.email_name(site).should == "installed_v1_w2"
--     end
-- 
       it "returns the proper name for sites that don't have a script installed" do
         site = double("site", :created_at => 1.day.ago, :script_installed_at => nil)
         Hello::EmailDigest.email_name(site).should == "not_installed_v1_w1"
-- 
         site = double("site", :created_at => 8.days.ago, :script_installed_at => nil)
         Hello::EmailDigest.email_name(site).should == "not_installed_v1_w2"
--     end
-- 
       it "uses the script_installed_at attribute for determining cohort when installed" do
         site = double("site", :created_at => 8.days.ago, :script_installed_at => 1.day.ago)
         Hello::EmailDigest.email_name(site).should == "installed_v1_w1"
--     end
--   end
-- 
     describe "site_metrics" do
       before(:each) do
         Timecop.freeze(Time.parse("Mon Apr 28 06:30:00 CDT 2014"))
-- 
         @site = sites(:zombo)
         @social_bar = bars(:zombo_twitter)
         @traffic_bar = bars(:zombo_traffic)
         @email_bar = bars(:zombo_email)
--     end
-- 
       after(:each) do
         Timecop.return
--     end
-- 
       it "does not include lift unless the script has been installed for two full weeks" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([
--         Hello::BarData.new(@site.id, @social_bar.id, 1.day.ago.strftime("%Y%m%d").to_i, 12, 11)
--       ])
-- 
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:social][:views][:lift].should == nil
         data[:social][:actions][:lift].should == nil
         data[:social][:conversion][:lift].should == nil
--     end
-- 
       it "does not include data for bar types that haven't been created" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([
--         Hello::BarData.new(@site.id, @social_bar.id, 1.day.ago.strftime("%Y%m%d").to_i, 12, 11)
--       ])
-- 
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:traffic].should == nil
         data[:email].should == nil
--     end
-- 
       it "separates statistics by bar type" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([
--         Hello::BarData.new(@site.id, @social_bar.id, 1.day.ago.strftime("%Y%m%d").to_i, 12, 11),
--         Hello::BarData.new(@site.id, @traffic_bar.id, 1.day.ago.strftime("%Y%m%d").to_i, 34, 33),
--         Hello::BarData.new(@site.id, @traffic_bar.id, 2.days.ago.strftime("%Y%m%d").to_i, 56, 55)
--       ])
-- 
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:social][:views][:n].should == 12
         data[:social][:actions][:n].should == 11
         data[:social][:conversion][:n].should be_within(0.01).of(11.0/12)
         data[:traffic][:views][:n].should == 90
         data[:traffic][:actions][:n].should == 88
         data[:traffic][:conversion][:n].should be_within(0.01).of(88.0/90)
         data[:email].should == nil
--     end
-- 
       it "includes lift data if the script has been installed for two full weeks and there is enough bar data" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([
--         Hello::BarData.new(@site.id, @traffic_bar.id, 1.day.ago.strftime("%Y%m%d").to_i, 34, 33),
--         Hello::BarData.new(@site.id, @traffic_bar.id, 9.days.ago.strftime("%Y%m%d").to_i, 56, 55)
--       ])
-- 
         @site.script_installed_at = 15.days.ago
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:traffic][:views][:n].should == 34
         data[:traffic][:actions][:n].should == 33
         data[:traffic][:conversion][:n].should be_within(0.01).of(33.0/34)
         data[:traffic][:views][:lift].should be_within(0.01).of((34 - 56) / 56.0)
         data[:traffic][:actions][:lift].should be_within(0.01).of((33 - 55) / 55.0)
         data[:traffic][:conversion][:lift].should be_within(0.01).of(((33.0/34) - (55.0/56)) / (55.0/56))
--     end
-- 
       it "totals this week's data" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([
--         Hello::BarData.new(@site.id, @social_bar.id, 1.day.ago.strftime("%Y%m%d").to_i, 12, 11),
--         Hello::BarData.new(@site.id, @traffic_bar.id, 1.day.ago.strftime("%Y%m%d").to_i, 34, 33),
--         Hello::BarData.new(@site.id, @traffic_bar.id, 8.days.ago.strftime("%Y%m%d").to_i, 56, 55)
--       ])
-- 
         @site.script_installed_at = 15.days.ago
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:total][:views][:n].should == 46
         data[:total][:actions][:n].should == 44
         data[:total][:conversion][:n].should be_within(0.01).of(44.0/46)
         data[:total][:views][:lift].should be_within(0.01).of((46 - 56) / 56.0)
         data[:total][:actions][:lift].should be_within(0.01).of((44 - 55) / 55.0)
         data[:total][:conversion][:lift].should be_within(0.01).of(((44.0/46) - (55.0/56)) / (55.0 / 56))
--     end
-- 
       it "handles no bar data" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([])
-- 
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:social].should == nil
         data[:traffic].should == nil
         data[:email].should == nil
         data[:total].should == nil
--     end
-- 
       it "works when there's data for last week but not this week" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([
--         Hello::BarData.new(@site.id, @email_bar.id, 8.days.ago.strftime("%Y%m%d").to_i, 0, 0),
--         Hello::BarData.new(@site.id, @traffic_bar.id, 8.days.ago.strftime("%Y%m%d").to_i, 56, 55)
--       ])
-- 
         @site.script_installed_at = 15.days.ago
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:total][:views][:n].should == 0
--     end
-- 
       it "computes lift totals correctly if there were no conversions last week" do
         Hello::BarData.should_receive(:get_over_time_data).and_return([
--         Hello::BarData.new(@site.id, @email_bar.id, 8.days.ago.strftime("%Y%m%d").to_i, 10, 0),
--         Hello::BarData.new(@site.id, @email_bar.id, 1.days.ago.strftime("%Y%m%d").to_i, 10, 4)
--       ])
-- 
         @site.script_installed_at = 15.days.ago
         data = Hello::EmailDigest.site_metrics(@site)
-- 
         data[:total][:views][:lift].should == 0.0
         data[:total][:actions][:lift].should == nil
         data[:total][:conversion][:lift].should == nil
--     end
--   end
-- 
     describe "create_bar_cta" do
       before do
         @metrics = {
--         :traffic => {:conversion => {:n => 0.8}},
--         :email =>   {:conversion => {:n => 0.4}},
--         :social =>  {:conversion => {:n => 0.2}}
--       }
-- 
         @url = ""
         @site = sites(:polymathic)
         @site.create_default_rule
--     end
-- 
       it "suggests creation of a social bar if there aren't any" do
         @site.rules.first.bars = [
           Bar.new.tap{|b| b.bar_type = "traffic"},
           Bar.new.tap{|b| b.bar_type = "email"}
--       ]
-- 
         Hello::EmailDigest.create_bar_cta(@site, @metrics, @url).should =~ /gaining followers/
--     end
-- 
       it "suggests creation of an email bar if there aren't any" do
         @site.rules.first.bars = [
           Bar.new.tap{|b| b.bar_type = "traffic"},
           Bar.new.tap{|b| b.bar_type = "social/tweet_on_twitter"}
--       ]
-- 
         Hello::EmailDigest.create_bar_cta(@site, @metrics, @url).should =~ /collecting email/
--     end
-- 
       it "suggests creation of a traffic bar if there aren't any" do
         @site.rules.first.bars = [
           Bar.new.tap{|b| b.bar_type = "social/tweet_on_twitter"},
           Bar.new.tap{|b| b.bar_type = "email"}
--       ]
-- 
         Hello::EmailDigest.create_bar_cta(@site, @metrics, @url).should =~ /driving traffic/
--     end
-- 
       it "suggests creation of a second bar of the worst-performing type, if at least one of each bar already exists" do
         @site.rules.first.bars = [
           Bar.new.tap{|b| b.bar_type = "social/follow_on_twitter"},
           Bar.new.tap{|b| b.bar_type = "email"},
           Bar.new.tap{|b| b.bar_type = "traffic"}
--       ]
-- 
         Hello::EmailDigest.create_bar_cta(@site, @metrics, @url).should =~ /Start testing more social bars/
--     end
-- 
       it "uses dynamic bar units in 'worst-performing' CTA" do
         @site.rules.first.bars = [
           Bar.new.tap{|b| b.bar_type = "social/follow_on_twitter"},
           Bar.new.tap{|b| b.bar_type = "email"},
           Bar.new.tap{|b| b.bar_type = "traffic"}
--       ]
-- 
         Hello::EmailDigest.create_bar_cta(@site, @metrics, @url).should =~ /get more followers/
--     end
--   end
-- end

================================================================================
 ./spec/lib/hello/tracking_param_spec.rb
================================================================================
   require "spec_helper"
-- 
   describe Hello::TrackingParam do
     fixtures :all
-- 
     it "encodes and decodes a tracker" do
       user_id = "1"
       action = "click"
       data = "some url"
       tracker = Hello::TrackingParam.encode_tracker(user_id, action, data)
-- 
       Hello::TrackingParam.decode_tracker(tracker).should == [user_id, action, data]
       URI::escape(tracker).should == tracker
--   end
-- 
     it "can handle cgi-escaped params" do
       tracker = "MTIvLy9vcGVuLy8vRHJpcCAxLy8vMDk0MDhmZjk%3D"
       Hello::TrackingParam.decode_tracker(tracker).should == ["12", "open", "Drip 1"]
--   end
-- 
     describe "::track" do
       it "decodes and records a tracking parameters" do
         tracker = Hello::TrackingParam.encode_tracker("1", "click", "some url")
         Hello::Tracking.should_receive(:track_event).with("user", "1", "Clicked link: some url")
-- 
         Hello::TrackingParam.track(tracker)
--     end
--   end
-- end

================================================================================
 ./spec/lib/legacy_migrator/date_time_converter_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe LegacyMigrator::DateTimeConverter do
     class SexyTime
       extend LegacyMigrator::DateTimeConverter
--   end
-- 
     context '#convert_start_time' do
       it 'returns nil if start time is blank' do
         SexyTime.convert_start_time('', '').should be_blank
--     end
-- 
       it 'converts start time properly' do
         date_string = "2014-12-25"
         timezone = "(GMT-05:00) Eastern Time (US & Canada)"
-- 
         expected_time_string = "2014-12-25T00:00:00-05:00"
-- 
         SexyTime.convert_start_time(date_string, timezone).to_s.should == expected_time_string
--     end
-- 
       it 'handles crazy other timezones just in case' do
         date_string = "2014-12-25"
         timezone = "(GMT-11:00) American Samoa"
-- 
         expected_time_string = "2014-12-25T00:00:00-11:00"
-- 
         SexyTime.convert_start_time(date_string, timezone).to_s.should == expected_time_string
--     end
-- 
       it 'handles visitor as a UTC timezone' do
         date_string = "2014-12-25"
         timezone = "visitor"
-- 
         expected_time_string = "2014-12-25T00:00:00+00:00"
-- 
         SexyTime.convert_start_time(date_string, timezone).to_s.should == expected_time_string
--     end
--   end
-- 
     context '#convert_end_time' do
       it 'returns nil if end time is blank' do
         SexyTime.convert_end_time('', '').should be_blank
--     end
-- 
       it 'converts end time properly' do
         date_string = "2014-12-25"
         timezone = "(GMT-05:00) Eastern Time (US & Canada)"
-- 
         expected_time_string = "2014-12-25T23:59:59-05:00"
-- 
         SexyTime.convert_end_time(date_string, timezone).to_s.should == expected_time_string
--     end
-- 
       it 'handles crazy other timezones just in case' do
         date_string = "2014-12-25"
         timezone = "(GMT-11:00) American Samoa"
-- 
         expected_time_string = "2014-12-25T23:59:59-11:00"
-- 
         SexyTime.convert_end_time(date_string, timezone).to_s.should == expected_time_string
--     end
-- 
       it 'handles visitor as a UTC timezone' do
         date_string = "2014-12-25"
         timezone = "visitor"
-- 
         expected_time_string = "2014-12-25T23:59:59+00:00"
-- 
         SexyTime.convert_end_time(date_string, timezone).to_s.should == expected_time_string
--     end
--   end
-- end

================================================================================
 ./spec/lib/legacy_migrator_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe LegacyMigrator, '.migrate_sites_and_users_and_memberships' do
     let(:legacy_site) { double 'legacy_site', legacy_site_id: 44332211, id: 11223344, base_url: 'http://baller4ever.sho', account_id: 1, created_at: Time.parse('1875-01-30'), updated_at: Time.parse('1875-01-31'), script_installed_at: Time.now, generated_script: Time.now, attempted_generate_script: Time.now }
-- 
     context 'site migration' do
       before do
         LegacyMigrator::LegacySite.should_receive(:find_each).and_yield(legacy_site)
--     end
-- 
       it 'creates a new site with LegacySite#legacy_site_id if present' do
         LegacyMigrator.stub :create_user_and_membership
-- 
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
         }.to change{ Site.exists?(legacy_site.legacy_site_id) }.from(false).to(true)
--     end
-- 
       it 'creates a new site with LegacySite#id' do
         legacy_site.stub legacy_site_id: nil
         LegacyMigrator.stub :create_user_and_membership
-- 
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
         }.to change{ Site.exists?(legacy_site.id) }.from(false).to(true)
--     end
-- 
       it 'creates a new site with LegacySite#created_at' do
         LegacyMigrator.stub :create_user_and_membership
-- 
         LegacyMigrator.migrate_sites_and_users_and_memberships
-- 
         Site.find(legacy_site.legacy_site_id).created_at.should == legacy_site.created_at
--     end
-- 
       it 'creates a new site with LegacySite#updated_at' do
         LegacyMigrator.stub :create_user_and_membership
-- 
         LegacyMigrator.migrate_sites_and_users_and_memberships
-- 
         Site.find(legacy_site.legacy_site_id).updated_at.should == legacy_site.updated_at
--     end
--   end
-- 
     context 'user and membership migration' do
       before do
         LegacyMigrator::LegacySite.should_receive(:find_each).and_yield(legacy_site)
         legacy_user.stub legacy_user_id: 11223344, id: 44332211, email: "rand#{rand(10_0000)}-#{rand(10_000)}@email.com", original_created_at: Time.parse('1824-05-07')
--     end
-- 
       let(:legacy_account) { double 'legacy_account', memberships: [legacy_membership] }
       let(:legacy_membership) { double 'legacy_membership', id: 1, user: legacy_user }
       let(:legacy_user) { LegacyMigrator::LegacyUser.new }
-- 
       before do
         LegacyMigrator::LegacyAccount.stub find: legacy_account
--     end
-- 
       it 'does not create a user if it already exists' do
         User.stub :exists? => true
-- 
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
--       }.to_not change(User, :count)
--     end
-- 
       it 'skips creating a user if no legacy user can be found' do
         legacy_membership.stub user: nil
-- 
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
--       }.to_not change(User, :count)
--     end
-- 
       it 'skips creating a site membership if no legacy user can be found' do
         legacy_membership.stub user: nil
-- 
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
--       }.to_not change(SiteMembership, :count)
--     end
-- 
       it 'creates a new user with the LegacyUser#legacy_user_id if it exists' do
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
         }.to change{ User.exists?(legacy_user.legacy_user_id) }.from(false).to(true)
--     end
-- 
       it 'creates a new user with the LegacyUser#id if there is no legacy id' do
         legacy_user.stub legacy_user_id: nil
-- 
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
         }.to change{ User.exists?(legacy_user.id) }.from(false).to(true)
--     end
-- 
       it 'creates a new user with the LegacyUser#original_created_at if present' do
         expect {
           LegacyMigrator.migrate_sites_and_users_and_memberships
--       }.to change(User, :count).by(1)
-- 
         new_user = User.find(legacy_user.legacy_user_id)
-- 
         new_user.created_at.should == legacy_user.original_created_at
--     end
-- 
       it 'creates a new user with the LegacyUser#created_at if no original_created_at is present' do
         legacy_user.stub original_created_at: nil, created_at: Time.parse('1971-12-19')
         LegacyMigrator.migrate_sites_and_users_and_memberships
-- 
         new_user = User.find(legacy_user.legacy_user_id)
-- 
         new_user.created_at.should == legacy_user.created_at
--     end
-- 
       it 'creates a new user with the LegacyUser#updated_at' do
         legacy_user.stub updated_at: Time.parse('2007-10-23')
         LegacyMigrator.migrate_sites_and_users_and_memberships
-- 
         new_user = User.find(legacy_user.legacy_user_id)
-- 
         new_user.updated_at.should == legacy_user.updated_at
--     end
-- 
       it 'associates the site and user with a new SiteMembership' do
         LegacyMigrator.migrate_sites_and_users_and_memberships
-- 
         new_user = User.find(legacy_user.legacy_user_id)
         new_site = Site.find(legacy_site.legacy_site_id)
-- 
         new_user.sites.should == [new_site]
--     end
--   end
-- end
-- 
   describe LegacyMigrator, '.migrate_goals_to_rules' do
     let(:start_date) { '2013-12-01' }
     let(:end_date) { '2014-06-05' }
     let(:legacy_goal) { double 'legacy_goal', id: 12345, site_id: legacy_site.id, data_json: {}, created_at: Time.parse('2000-01-31'), updated_at: Time.now, type: "Goals::DirectTraffic", priority: 1 }
     let(:legacy_site) { double 'legacy_site', id: 123 }
     let(:bar_settings) { { 'message' => 'goes here' } }
     let(:legacy_bar) { double 'legacy_bar', legacy_bar_id: 123, active?: true, created_at: Time.parse('2001-09-11'), updated_at: Time.now, target_segment: 'dv:computer', goal_id: 'legacy_goal.id', settings_json: bar_settings }
-- 
     before do
       Site.stub :exists? => true
       legacy_goal.stub bars: [legacy_bar]
       LegacyMigrator::LegacyGoal.should_receive(:find_each).and_yield(legacy_goal)
--   end
-- 
     it 'doesnt create a new ruleset if the goal belongs to a site that doesnt exist' do
       Site.stub :exists? => false
-- 
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to_not change(Rule, :count)
--   end
-- 
     it 'creates a new rule set with the proper attributes' do
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to change(Rule, :count).by(1)
-- 
       rule = Rule.find(legacy_goal.id)
-- 
       rule.id.should == legacy_goal.id
       rule.site_id.should == legacy_site.id
       rule.created_at.to_s.should == legacy_goal.created_at.to_time.utc.to_s
       rule.updated_at.to_s.should == legacy_goal.updated_at.to_time.utc.to_s
--   end
-- 
     it 'creates a new bar for every legacy bar that exists' do
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to change(Bar, :count).by(1)
--   end
-- 
     it 'associates all newly created bars with the new rule set' do
       LegacyMigrator.migrate_goals_to_rules
-- 
       Rule.find(legacy_goal.id).bars.count.should == 1
--   end
-- 
     it 'standardizes the legacy goal type' do
       LegacyMigrator.migrate_goals_to_rules
-- 
       bar = Rule.find(legacy_goal.id).bars.first
-- 
       bar.bar_type.should == 'traffic'
--   end
-- 
     it 'standardizes the legacy goal type for social bars' do
       legacy_goal.stub(:type => "Goals::SocialMedia")
       legacy_goal.stub(:data_json => {"interaction" => "tweet_on_twitter"})
-- 
       LegacyMigrator.migrate_goals_to_rules
-- 
       bar = Rule.find(legacy_goal.id).bars.first
-- 
       bar.bar_type.should == 'social/tweet_on_twitter'
--   end
-- 
     it 'copies over legacy goal social settings to bar' do
       legacy_goal.stub data_json: { 'buffer_message' => 'such buffer. wow.' }
-- 
       LegacyMigrator.migrate_goals_to_rules
-- 
       bar = Rule.find(legacy_goal.id).bars.first
-- 
       bar.settings.should == { 'buffer_message' => 'such buffer. wow.' }
--   end
-- 
     it 'creates a new DateCondition if start_date is specified' do
       legacy_goal.stub data_json: { 'start_date' => start_date }
-- 
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to change(Condition, :count).by(1)
--   end
-- 
     it 'creates a new DateRule if end_date is specified' do
       legacy_goal.stub data_json: { 'end_date' => end_date }
-- 
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to change(Condition, :count).by(1)
--   end
-- 
     it 'creates a new DateRule with the proper values when both start_date and end_date are specified' do
       legacy_goal.stub data_json: { 'start_date' => start_date, 'end_date' => end_date }
-- 
       LegacyMigrator.migrate_goals_to_rules
-- 
       condition = Rule.find(legacy_goal.id).conditions.first
-- 
       condition.value.should == { 'start_date' => DateTime.parse(start_date + " 00:00:00"), 'end_date' => DateTime.parse(end_date + " 23:59:59") }
--   end
-- 
     it 'creates a new UrlRule if include_urls is specified' do
       legacy_goal.stub data_json: { 'include_urls' => ['http://url.com'] }
-- 
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to change(Condition, :count).by(1)
--   end
-- 
     it 'creates a new UrlRule if exclude_urls is specified' do
       legacy_goal.stub data_json: { 'exclude_urls' => ['http://url.com'] }
-- 
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to change(Condition, :count).by(1)
--   end
-- 
     it 'creates a new UrlRule if both exclude_urls and are specified' do
       data = { 'exclude_urls' => ['http://exclude.com'], 'include_urls' => ['http://include.com'] }
       legacy_goal.stub data_json: data
-- 
       LegacyMigrator.migrate_goals_to_rules
-- 
       conditions = Rule.find(legacy_goal.id).conditions
-- 
       conditions.find{|condition| condition.value.has_key?('include_url') }.value.should == { 'include_url' => 'http://include.com' }
       conditions.find{|condition| condition.value.has_key?('exclude_url') }.value.should == { 'exclude_url' => 'http://exclude.com' }
--   end
-- 
     it 'creates both a DateRule and a UrlRule for every url present when start_date and include_urls are specified' do
       data = { 'exclude_urls' => ['http://include.com', 'http://another.com'], 'include_urls' => ['http://exclude.com'], 'start_date' => '01/01/2001', 'end_date' => '12/12/2012' }
       legacy_goal.stub data_json: data
-- 
       expect {
         LegacyMigrator.migrate_goals_to_rules
--     }.to change(Condition, :count).by(4)
--   end
-- end

================================================================================
 ./spec/lib/script_generator_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe ScriptGenerator, '#render' do
     let(:site) { double 'site', id: '1337', rules: [], bars: double('bars', active: []) }
     let(:generator) { ScriptGenerator.new(site) }
-- 
     it 'renders the site it variable' do
       expected_string = "var HB_SITE_ID = #{site.id};"
-- 
       generator.render.should include(expected_string)
--   end
-- 
     it 'renders the backend host variable' do
       Hellobar::Settings.stub(:[]).with(:tracking_host).and_return("hi-there.hellobar.com")
       expected_string = "HB_BACKEND_HOST = \"hi-there.hellobar.com\";"
-- 
       generator.render.should include(expected_string)
--   end
-- 
     it 'renders the hellobar base file' do
       hellobar_base = File.read("#{Rails.root}/vendor/assets/javascripts/hellobar.base.js")
-- 
       generator.render.should include(hellobar_base)
--   end
-- 
     it 'includes the minified hellobar css' do
       generator.stub :hellobar_container_css
       hellobar_css = File.read("#{Rails.root}/vendor/assets/stylesheets/hellobar_script.css")
-- 
       CSSMin.should_receive(:minify).with(hellobar_css).and_return(hellobar_css)
-- 
       generator.render.should include(hellobar_css.to_json)
--   end
-- 
     it 'includes the hellobar container css' do
       generator.stub :hellobar_base_css
       container_css = File.read("#{Rails.root}/vendor/assets/stylesheets/hellobar_script_container.css")
-- 
       CSSMin.should_receive(:minify).with(container_css).and_return(container_css)
-- 
       generator.render.should include(container_css.to_json)
--   end
-- 
     it 'renders the initialization of the hellobar queue object' do
       hbq_initialization = "_hbq = new HBQ();"
-- 
       generator.render.should include(hbq_initialization)
--   end
-- 
     context 'when templates are present' do
       it 'renders the setTemplate function on HB with the template name and markup' do
         template = { name: 'yey name', markup: 'yey markup' }
         generator.stub templates: [template]
-- 
         expected_string = "HB.setTemplate(\"yey name\", yey markup);"
-- 
         generator.render.should include(expected_string)
--     end
-- 
       it 'renders only the setTemplate definition and 1 call per bar type' do
         bar = double 'bar', bar_type: 'traffic'
         site.stub bars: double('bars', active: [bar, bar])
-- 
         generator = ScriptGenerator.new site
-- 
         generator.render.scan('setTemplate').size.should == 2
--     end
-- 
       it 'renders the setTemplate definition and 1 call per bar type for multiple types' do
         traffic_bar = double 'bar', bar_type: 'traffic'
         email_bar = double 'bar', bar_type: 'email'
         site.stub bars: double('bars', active: [traffic_bar, email_bar])
-- 
         generator = ScriptGenerator.new site
-- 
         generator.render.scan('setTemplate').size.should == 3
--     end
--   end
-- 
     context 'when rules are present' do
       it 'does not return any eligibility rules when eligibility is disabled' do
         generator = ScriptGenerator.new(site, { :disable_eligibility => true })
         rule = Rule.new
         date_condition = DateCondition.new value: { 'start_date' => 1_000, 'end_date' => 2_000 }
         url_condition = UrlCondition.new value: { 'include_url' => 'http://good.com', 'exclude_url' => 'http://other.com' }
         rule.stub conditions: [date_condition, url_condition]
         site.stub rules: [rule]
-- 
         unexpected_pattern = /\(new Date\(\)\)\.getTime\(\)\/(.*)|HB.umatch(.*);/
-- 
         generator.render.should_not match(unexpected_pattern)
--     end
-- 
       it 'has a start date constraint when present' do
         rule = Rule.new
         condition = DateCondition.new value: { 'start_date' => 1_000 }
         rule.stub conditions: [condition]
         site.stub rules: [rule]
-- 
         expected_string = '(new Date()).getTime()/1000 > 1000)'
-- 
         generator.render.should include(expected_string)
--     end
-- 
       it 'does NOT have a start date constraint when not present' do
         rule = Rule.new
         site.stub rules: [rule]
-- 
         unexpected_string = /\(new Date\(\)\)\.getTime\(\)\/1000/
-- 
         generator.render.should_not match(unexpected_string)
--     end
-- 
       it 'has an end date constraint when present' do
         rule = Rule.new
         condition = DateCondition.new value: { 'end_date' => 20_000 }
         rule.stub conditions: [condition]
         site.stub rules: [rule]
-- 
         expected_string = '(new Date()).getTime()/1000 < 20000)'
-- 
         generator.render.should include(expected_string)
--     end
-- 
       it 'does NOT have a start date constraint when not present' do
         rule = Rule.new
         site.stub rules: [rule]
-- 
         unexpected_string = /\(new Date\(\)\)\.getTime\(\)\//
-- 
         generator.render.should_not match(unexpected_string)
--     end
-- 
       it 'adds an exlusion constraint for all blacklisted URLs' do
         rule = Rule.new
         conditions = [UrlCondition.new(value: { 'exclude_url' => '/signup' })]
         rule.stub bars: double('bars', active: []), attributes: {}, conditions: conditions
         site.stub rules: [rule]
-- 
         expected_string = "(!HB.umatch(\"/signup\", document.location))"
-- 
         generator.render.should include(expected_string)
--     end
-- 
       it 'converts excluded urls to paths' do
         rule = Rule.new
         conditions = [UrlCondition.new(value: { 'exclude_url' => 'http://soamazing.com/signup' })]
         rule.stub bars: double('bars', active: []), attributes: {}, conditions: conditions
         site.stub rules: [rule]
-- 
         expected_string = "(!HB.umatch(\"/signup\", document.location))"
-- 
         generator.render.should include(expected_string)
--     end
-- 
       it 'does NOT have exclusion constraints when no sites are blacklisted' do
         rule = Rule.new
         site.stub rules: [rule]
-- 
         expected_string = Regexp.new /HB.umatch(.*)/
-- 
         generator.render.should_not match(expected_string)
--     end
-- 
       it 'adds an inclusion constraint for all whitelisted URLs' do
         rule = Rule.new
         conditions = [UrlCondition.new(value: { 'include_url' => '/signup' })]
         rule.stub conditions: conditions
         site.stub rules: [rule]
-- 
         expected_string = "(HB.umatch(\"/signup\", document.location));"
-- 
         generator.render.should include(expected_string)
--     end
-- 
       it 'does NOT have inclusion constraints when no sites are whitelisted' do
         rule = Rule.new
         generator.stub rules: [rule]
-- 
         expected_string = Regexp.new /HB.umatch(.*)/
-- 
         generator.render.should_not match(expected_string)
--     end
--   end
-- end
-- 
   describe ScriptGenerator, '#rules' do
     let(:site) { double 'site', id: '1337', rules: [], bars: [] }
     let(:generator) { ScriptGenerator.new(site) }
-- 
     it 'returns the proper array of hashes for a sites rules' do
       rule = Rule.new id: 1
       site.stub rules: [rule]
       generator.stub bars_for_rule: []
-- 
       expected_hash = {
--       bar_json: [].to_json,
--       priority: 1,
--       metadata: { "id" => 1 }.to_json,
--       rule_eligibility: 'return true;}'
--     }
-- 
       generator.rules.should == [expected_hash]
--   end
-- 
     it 'returns the proper hash when a single bar_id is passed as an option' do
       rule = Rule.create
       bar = Bar.create bar_type: 'email', rule: rule
       options = { bar_id: bar.id }
-- 
       generator = ScriptGenerator.new(site, options)
       generator.stub bar_settings: {id: bar.id, template_name: bar.bar_type}
-- 
       site.stub rules: [rule]
-- 
       expected_hash = {
--       bar_json: [{ id: bar.id, template_name: bar.bar_type }].to_json,
--       priority: 1,
--       metadata: { "id" => rule.id }.to_json,
--       rule_eligibility: 'return true;}'
--     }
-- 
       generator.rules.should == [expected_hash]
--   end
-- 
     it 'renders all bar json when the render_paused_bars is true' do
       rule = Rule.create
       bar = Bar.create bar_type: 'email', rule: rule, paused: true
       options = { render_paused_bars: true }
       generator = ScriptGenerator.new(site, options)
       generator.stub bar_settings: { id: bar.id, template_name: bar.bar_type, settings: { buffer_url: 'url' }}
-- 
       site.stub rules: [rule]
-- 
       expected_hash = {
--       bar_json: [{ id: bar.id, template_name: bar.bar_type, settings: { buffer_url: 'url' }}].to_json,
--       priority: 1,
--       metadata: { "id" => rule.id }.to_json,
--       rule_eligibility: 'return true;}'
--     }
-- 
       generator.rules.should == [expected_hash]
--   end
-- 
     it 'renders only active bar json by default' do
       rule = Rule.create
       paused = Bar.create! bar_type: 'email', rule: rule, paused: true
       active_bar = Bar.create! bar_type: 'traffic', rule: rule, paused: false
       generator = ScriptGenerator.new(site)
       generator.stub bar_settings: { id: active_bar.id, template_name: active_bar.bar_type }
-- 
       site.stub rules: [rule]
-- 
       expected_hash = {
--       bar_json: [{ id: active_bar.id, template_name: active_bar.bar_type }].to_json,
--       priority: 1,
--       metadata: { "id" => rule.id }.to_json,
--       rule_eligibility: 'return true;}'
--     }
-- 
       generator.rules.should == [expected_hash]
--   end
-- end
-- 
   describe ScriptGenerator, '#generate_script' do
     it 'does not compress the template if the compress option is not set' do
       generator = ScriptGenerator.new('site')
       generator.stub :render => 'template'
-- 
       Uglifier.should_not_receive(:new)
       generator.should_receive(:render)
-- 
       generator.generate_script
--   end
-- 
     it 'compresses the template when the compress option is true' do
       generator = ScriptGenerator.new('site', { compress: true })
       generator.stub :render => 'template'
-- 
       uglifier = Uglifier.new
       Uglifier.should_receive(:new).and_return(uglifier)
       uglifier.should_receive(:compress).with('template')
-- 
       generator.generate_script
--   end
-- end

================================================================================
 ./spec/models/admin_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe Admin do
     fixtures :all
-- 
     before(:each) do
       @admin = admins(:joey)
--   end
-- 
     it "can create a new record from email and mobile phone" do
       admin = Admin.make!("newadmin@polymathic.me", "5553211234")
       admin.should be_valid
--   end
-- 
     it "standardizes mobile phone on validation" do
       admin = Admin.new(:mobile_phone => "(555) 123-1234").tap{|a| a.valid?}
       admin.mobile_phone.should == "+15551231234"
--   end
-- 
     describe "::validate_session" do
       it "returns an admin with valid access token and session token" do
         Admin.validate_session(@admin.session_access_token, @admin.session_token).should == @admin
--     end
-- 
       it "returns nil if admin not found" do
         Admin.validate_session("gibber", "ish").should == nil
--     end
-- 
       it "returns nil if the session is too old" do
         @admin.should_receive(:session_last_active).and_return(Time.now - Admin::MAX_SESSION_TIME - 1.hour)
         Admin.should_receive(:where).and_return([@admin])
-- 
         result = Admin.validate_session("foo", "bar")
         result.should == nil
--     end
-- 
       it "returns nil if the admin is locked" do
         @admin.should_receive(:locked?).and_return(true)
         Admin.should_receive(:where).and_return([@admin])
-- 
         result = Admin.validate_session("foo", "bar")
         result.should == nil
--     end
-- 
       it "returns nil if session is old AND admin is locked" do
         @admin.stub(:locked?).and_return(true)
         @admin.stub(:session_last_active).and_return(Time.now - Admin::MAX_SESSION_TIME - 1.hour)
         Admin.should_receive(:where).and_return([@admin])
-- 
         result = Admin.validate_session("foo", "bar")
         result.should == nil
--     end
-- 
       it "bumps session_last_active is session is still good" do
         @admin.should_receive(:session_heartbeat!)
         Admin.should_receive(:where).and_return([@admin])
-- 
         Admin.validate_session("foo", "bar")
--     end
--   end
-- 
     describe "needs_mobile_code?" do
       it "returns false if we've validated this access token recently" do
         @admin.stub(:valid_access_tokens).and_return({"token" => [1.minute.ago.to_i, 1.minute.ago.to_i]})
         @admin.needs_mobile_code?("token").should be_false
--     end
-- 
       it "returns true if we've never validated this access token" do
         @admin.stub(:valid_access_tokens).and_return({})
         @admin.needs_mobile_code?("token").should be_true
--     end
-- 
       it "returns true if we validated this access token too long ago" do
         @admin.stub(:valid_access_tokens).and_return({"token" => [1.year.ago.to_i, 1.year.ago.to_i]})
         @admin.needs_mobile_code?("token").should be_true
--     end
--   end
-- 
     describe "send_new_mobile_code!" do
       it "sends a mobile code" do
         twilio = double(:twilio)
         Twilio::REST::Client.stub_chain("new.account.sms.messages").and_return(twilio)
-- 
         twilio.should_receive(:create).with(
--         :body => anything,
--         :to => @admin.mobile_phone,
--         :from => "+14157952691"
--       )
-- 
         @admin.send_new_mobile_code!
--     end
-- 
       it "sends no code if the admin is locked" do
         @admin.stub(:locked?).and_return(true)
         @admin.send_new_mobile_code!.should be_false
--     end
-- 
       it "locks the admin if too many codes have been sent" do
         @admin.mobile_codes_sent = Admin::MAX_MOBILE_CODES + 1
-- 
         Twilio::REST::Client.should_receive(:new).never
         @admin.should_receive(:lock!)
-- 
         @admin.send_new_mobile_code!
--     end
--   end
-- 
     it "send_validate_access_token_email! sends an email to the admin with correct URLs" do
       Pony.should_receive(:mail)
       @admin.send_validate_access_token_email!("token")
--   end
-- 
     describe "validate_login" do
       before(:each) do
         @admin.valid_access_tokens = {"token" => [Time.now.to_i, Time.now.to_i]}
--     end
-- 
       it "locks the admin if attempting to log in too many times" do
         @admin.update_attribute(:login_attempts, Admin::MAX_LOGIN_ATTEMPTS)
         @admin.should_not be_locked
-- 
         @admin.validate_login("token", "password", @admin.mobile_code)
-- 
         @admin.should be_locked
         @admin.login_attempts.should == Admin::MAX_LOGIN_ATTEMPTS + 1
--     end
-- 
       it "returns false if locked" do
         @admin.stub(:locked?).and_return(true)
         @admin.validate_login("token", "password", @admin.mobile_code).should be_false
--     end
-- 
       it "returns false if mobile code does not match" do
         @admin.stub(:needs_mobile_code?).and_return(true)
         @admin.validate_login("token", "password", "notthecode").should be_false
--     end
-- 
       it "returns false if the wrong password is used" do
         @admin.validate_login("token", "notthepassword", @admin.mobile_code).should be_false
--     end
-- 
       it "returns false if the access token is invalid" do
         @admin.validate_login("notthetoken", "password", @admin.mobile_code).should be_false
--     end
-- 
       it "logs the admin in if all params are valid" do
         @admin.stub(:needs_mobile_code?).and_return(true)
         @admin.should_receive(:login!)
         @admin.validate_login("token", "password", @admin.mobile_code).should be_true
--     end
--   end
-- 
     it "reset_password! resets password and notifies admin via email" do
       @admin.password_last_reset.should be < 1.minute.ago
-- 
       Pony.should_receive(:mail)
       @admin.should_receive(:set_password!).with("new_password")
-- 
       @admin.reset_password!("new_password")
-- 
       @admin.password_last_reset.should be > 1.minute.ago
--   end
-- 
     it "login! logs the admin in" do
       @admin.update_attributes(
--       :mobile_codes_sent => 2,
--       :login_attempts => 2,
--       :session_token => "",
--       :session_access_token => ""
--     )
-- 
       @admin.should_receive(:set_valid_access_token)
       @admin.should_receive(:session_heartbeat!)
-- 
       @admin.login!("new_token")
       @admin.reload
-- 
       @admin.mobile_codes_sent.should == 0
       @admin.login_attempts.should == 0
       @admin.session_token.should_not be_blank
       @admin.session_access_token.should_not be_blank
--   end
-- end

================================================================================
 ./spec/models/bar_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe Bar do
     fixtures :all
-- 
     it "belongs to a site through a rule set" do
       bar = bars(:zombo_traffic)
       bar.site.should == sites(:zombo)
-- 
       bar.rule = nil
       bar.site.should be_nil
--   end
-- end

================================================================================
 ./spec/models/condition/date_condition_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe DateCondition, '.create_from_params' do
     it 'creates a between condition when both start_date and end_date are present' do
       condition = DateCondition.create_from_params('start', 'end')
-- 
       condition.operand.should == Condition::OPERANDS[:is_between]
       condition.value['start_date'].should == 'start'
       condition.value['end_date'].should == 'end'
--   end
-- 
     it 'creates a start_date condition when only start_date is present' do
       condition = DateCondition.create_from_params('start', '')
-- 
       condition.operand.should == Condition::OPERANDS[:is_after]
       condition.value['start_date'].should == 'start'
       condition.value['end_date'].should be_nil
--   end
-- 
     it 'creates a end_date condition when only end_date is present' do
       condition = DateCondition.create_from_params('', 'end')
-- 
       condition.operand.should == Condition::OPERANDS[:is_before]
       condition.value['end_date'].should == 'end'
       condition.value['start_date'].should be_nil
--   end
-- 
     it 'does nothing when neither start nor end date are present' do
       expect {
         DateCondition.create_from_params('', '')
--     }.to_not change(Condition, :count)
--   end
-- end

================================================================================
 ./spec/models/condition/url_condition_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe UrlCondition, '.create_include_url' do
     it 'creates the correct url condition with the correct operand' do
       url = 'http://googley.com'
-- 
--     UrlCondition.should_receive(:create).
         with({ operand: Condition::OPERANDS[:includes], value: { 'include_url' => url } })
-- 
       UrlCondition.create_include_url(url)
--   end
-- end
-- 
   describe UrlCondition, '.create_exclude_url' do
     it 'creates the correct url condition with the correct operand' do
       url = 'http://moogley.com'
-- 
--     UrlCondition.should_receive(:create).
         with({ operand: Condition::OPERANDS[:excludes], value: { 'exclude_url' => url } })
-- 
       UrlCondition.create_exclude_url(url)
--   end
-- end
-- 
   describe UrlCondition, '#url' do
     it 'returns the include_url if present' do
       condition = UrlCondition.new value: { 'include_url' => 'include' }
-- 
       condition.url.should == 'include'
--   end
-- 
     it 'returns the exclude_url if present' do
       condition = UrlCondition.new value: { 'exclude_url' => 'exclude' }
-- 
       condition.url.should == 'exclude'
--   end
     it 'returns nil when neither include_url nor exclude_url are present' do
       UrlCondition.new.url.should be_nil
--   end
-- end

================================================================================
 ./spec/models/internal_report_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe InternalReport do
     before do
       InternalReport.clear
--   end
-- 
     it "should return nil for a report not yet set" do
       InternalReport.get_data("test").should == nil
--   end
-- 
     it "should let you return a report that is set" do
       data = {"foo"=>"bar"}
       InternalReport.set("test", data)
       InternalReport.get_data("test").should == data
--   end
-- 
     it "should let you update an existing report" do
       data = {"foo"=>"bar"}
       InternalReport.set("test", data)
       InternalReport.get_data("test").should == data
       data = {"foo"=>"bar2"}
       InternalReport.set("test", data)
       InternalReport.get_data("test").should == data
--   end
-- 
     it "should not error out when you generate the reports" do
       InternalReport.generate_all
--   end
-- end

================================================================================
 ./spec/models/site_membership_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe SiteMembership do
     fixtures :all
-- 
     it "can only have one owner per site" do
       membership = SiteMembership.new(:site => sites(:zombo), :user => users(:wootie), :role => "editor")
       membership.should be_valid
-- 
       membership.role = "owner"
       membership.should_not be_valid
--   end
-- end

================================================================================
 ./spec/models/site_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe Site do
     fixtures :all
-- 
     before(:each) do
       @site = sites(:zombo)
--   end
-- 
     it_behaves_like "an object with a valid url"
-- 
     it "is able to access its owner" do
       @site.owner.should == users(:joey)
--   end
-- 
     describe "url formatting" do
       it "adds the protocol if not present" do
         site = Site.new(:url => "zombo.com")
         site.valid?
         site.url.should == "http://zombo.com"
--     end
-- 
       it "uses the supplied protocol if present" do
         site = Site.new(:url => "https://zombo.com")
         site.valid?
         site.url.should == "https://zombo.com"
-- 
         site = Site.new(:url => "http://zombo.com")
         site.valid?
         site.url.should == "http://zombo.com"
--     end
-- 
       it "removes the path, if provided" do
         urls = %w(
--         zombo.com/welcometozombocom
--         zombo.com/anythingispossible?at=zombocom
--         zombo.com?theonlylimit=yourimagination&at=zombocom#welcome
--       )
-- 
         urls.each do |url|
           site = Site.new(:url => url)
           site.valid?
           site.url.should == "http://zombo.com"
--       end
--     end
-- 
       it "accepts valid inputs" do
         urls = %w(
--         zombo.com
--         http://zombo.com/
--         http://zombo.com/welcome
--         http://zombo2.com/welcome
--         horse.bike
--       )
-- 
         urls.each do |url|
           site = Site.new(:url => url)
           site.valid?
           site.errors[:url].should be_empty
--       end
--     end
--   end
-- 
     describe "#script_content" do
       it "generates the contents of the script for a site" do
         script = @site.script_content(false)
-- 
         script.should =~ /HB_SITE_ID/
         script.should include(@site.bars.first.id.to_s)
--     end
-- 
       it "generates the compressed contents of the script for a site" do
         script = @site.script_content
-- 
         script.should =~ /HB_SITE_ID/
         script.should include(@site.bars.first.id.to_s)
--     end
--   end
-- 
     describe "#generate_static_assets" do
       it "generates and uploads the script content for a site" do
         script_content = @site.script_content(true)
         script_name = @site.script_name
-- 
         mock_storage = double("asset_storage")
         mock_storage.should_receive(:create_or_update_file_with_contents).with(script_name, script_content)
         Hello::AssetStorage.stub(:new => mock_storage)
-- 
         @site.generate_script
--     end
--   end
-- 
     it "blanks-out the site script when destroyed" do
       mock_storage = double("asset_storage")
       mock_storage.should_receive(:create_or_update_file_with_contents).with(@site.script_name, "")
       Hello::AssetStorage.stub(:new => mock_storage)
-- 
       @site.destroy
--   end
-- 
     describe "#has_script_installed?" do
       it "is true if script_installed_at is set" do
         @site.script_installed_at = 1.day.ago
         @site.has_script_installed?.should be_true
--     end
-- 
       it "is false if no bars have views" do
         @site.stub(:bars => [double("bar", :total_views => 0)])
         @site.has_script_installed?.should be_false
         @site.script_installed_at.should be_nil
--     end
-- 
       it "is true and sets script_installed_at if at least one bar has been viewed" do
         @site.stub(:bars => [double("bar", :total_views => 1)])
         @site.has_script_installed?.should be_true
         @site.script_installed_at.should_not be_nil
--     end
--   end
-- end

================================================================================
 ./spec/models/user_spec.rb
================================================================================
   require 'spec_helper'
-- 
   describe User do
     it "cannot have the same email as someone in the wordpress database" do
       Hello::WordpressUser.should_receive(:email_exists?).with("foo@bar.com").and_return(true)
-- 
       user = User.create(:email => "foo@bar.com")
-- 
       user.errors.messages[:email].should include("has already been taken")
--   end
-- end

================================================================================
 ./spec/models/validators/url_validator_shared.rb
================================================================================
   require 'spec_helper'
-- 
   shared_examples "an object with a valid url" do
     class WebClass
       include ActiveModel::Validations
-- 
       attr_accessor :url
-- 
       validates_with UrlValidator, url_field: :url
--   end
-- 
     let(:webby) { WebClass.new }
-- 
     it 'requires the url field' do
       webby.url = ""
-- 
       webby.should_not be_valid
       webby.errors[:url].should include("can't be blank")
--   end
-- 
     it "requires a url with a valid format" do
       urls = %w(
--       lololol
--       1234
--       me@notaurl.com
--       ftp://warez.dfnet.org
--     )
-- 
       urls.each do |url|
         test_case = WebClass.new
         test_case.url = url
-- 
         test_case.should_not be_valid
         test_case.errors[:url].should include("is invalid")
--     end
--   end
-- 
     it "accepts valid inputs" do
       urls = %w(
--       http://zombo.com
--       http://horse.bike
--       http://madam-e.ru
--       http://ec2-174-129-140-89.compute-1.amazonaws.com
--     )
-- 
       urls.each do |url|
         test_case = WebClass.new
         test_case.url = url
-- 
         test_case.should be_valid
--     end
--   end
-- end

